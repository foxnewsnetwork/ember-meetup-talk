# Talk Transcript

Here is a rough outline of my talk.

## Outline / transcript
- Introduce the problem of state
  - preamble
    * (!slide with name and intro) My name is Tom Chen, I am a software engineer here at Sony.
    * let's talk about state. (!slide with bad code) states and managing states in your code is always bad, and seems to consistently lead to (!slide with Hickley), as Rich Hickey puts it, "complecting" your application until you inevitably reach the (!slide with meme matrix) 'technological debt singularity' where every one change or fix to the code-base causes your app to break in two or more other places - (!slide with hydra)
    * (!slide with observer antipattern) Antipatterns like state-mutating observers, actions pretending to be events, async promises in your presentation layer, (!slide with if-else block) side-effect driven if-else blocks, etc., while seemingly friendly and harmless and familiar tenants of OO programming, are actually what eventually drives ember developers to snap and rm -rf their repos and start over. (!slide with scene from shining) I don't know about you, but your business is definitely not going to enjoy that process.

  - ‘If’, ‘set’, and ‘observe’ creates black magic code
    * We know that ember.js is an awesome power tool for building ambitious application, because specifically because the power, even the most competent developer can find him or herself occasionally succumb to the temptation of the creating some of our aforementioned ember anti-patterns.
    * (!slide with if-statement code) Consider the following innocent code snippet that mutates a controller state on an action
    * (!slide with clock) over time, given the natural tendency of code entropy, it might evolve to this (!slide with worse code)
    * (!slide with bus hitting developer) and suppose your tech lead happens to be on vacation when (!slide with deadline) some deadline or critical bug hits and some filthy (!slide with pointer at presenter) casual dev like me forces a commit like this in to solve our pressing issue (!slide with worst code of all)
    * then things go back to normal... except now there's awful code in our code repo that only this guy (!slide with arrow again) knows how to work with - which means everyone now has to work around and on top of this guy's trash, and bam, (!slide with broken code) we now have in our app the only thing worse than broken code - awful black magic code that becomes the foundation of your app.

  - Objects can’t properly encapsulate because `_privateDontTouch` will still be touched if things get desperate (what’s worse than broken code? Bad code that works)
    * (!slide with private variable named `_privateDontTouch`)  if state is living everywhere and can be modified anywhere - which it can because javascript is the peeping tom of languages - it will mutate on you anywhere. And while this is a tremendous strength in giving js flexibility, it's also a huge weakness as such great power comes with great responsibility. (!slide with resistance horse with NSFW text cropped out) And in times of great need or desparation, saying "no, don't look in that file and don't touch this folder" does nothing - it will inevitably get modified and entangled everywhere regardless of developer competence.

- Sell the redux solution
  - preamble
    * So what can we do? (!slide with glimmer) if we go back to 2014 during the latter days of the ember 1.x series, you'll recall ember had a problem where constant updates to the DOM resulted in extremely slow rendering and terrible frame-rates. The solution then was to look to react and assimilate their shadow dom into ember. (!slide with locutus of borg) Our glorious leader Yehuda and Canadian side-kick Godfrey jumped on this and thus glimmer 1 was born. 
    * (!slide with resistance is futile) today, we're encountering a similar problem where micromanaging application state is becoming a headache, so let's go back to the react federation (!slide with brent spinner as data) and see if we can't appropriate some sort of Data management from them. After all, despite the friendliness of our hamster (!slide with borg tomster), we are the BORG of javascript frameworks and so it is our duty as upstanding borg citizens to assimiliate good stuff from other frameworks.
    * (!slide with redux) Luckily, the good folks at facebook did come up with a reasonably good solution with redux which has already been shimmed twice into ember.js with `ember-redux` by toranb and `ember-cli-redux` by altschools
    * So what is redux? the TL;DR of it is that it is a...
  - God state pojo
    * (!slide with a big pojo) is god pojo that presents the entire mutable state of your app
  - Stateless transforms
    * (!slide with reducers and that redux gif) and your app changes state via a pub-sub mechanism to call 'reducers' functions that consume the current state and a pojo of instructions regarding how to return a new state
  - Why?!
    * (!slide with the 3 koma meme of the business men who look at propositions and are unimpressed at first, but excited at the last frame despite minor unimpressive changes) So if you haven't worked with redux before, you're probably thinking right now "this is 2016, and you're trying to throw battle-tested Object-Oriented out the window and sell me on pub-sub? C'mon facebook-shill, if there was an 'unlike' button for this talk, I'd press it right now."
    * (!slide with java, c++) And it's true, for a good number of us who hail from more traditional language backgrounds, the so-called "functional" way of thinking is a hard sell... but think about this; any given business application is actually extremely simply if you break it down to business terms (!slide with gnatflix business model) In this logic, we have games, users, and streams; notice that no data here is or needs to be "private". In fact, only when we get to having to implement our simple business logic onto the complex mess that is javascript, do we have to introduce "private" variables concerning our implementation or optimization.
    * but Javascript doesn't support true variable encapsulation and if you're app is concerning itself with solving framework level problems at the business application level, your app will eventually become a mess - because if business pressure to ship gets high enough, then no details-of-implementation variable is private enough, and no side effect unintuitive enough to keep the desperate programmer from doing what he or she must. (!slide with desperate times for desperate measures) desperate times call for desperate measures.
    * Unfortunately, a true cohesive argument for a functional pure approach to programming is well beyond the scope of my humble talk (and probably, one some level, not entirely appropriate for javascript development), (!slide with decaprio in inception) but I do ask that we take a leap of faith and trust in the giants of our industry that redux is good paradigm and can and should work within ember.
    * (!slide with what redux gets rid of for you) specifically, switching to redux state management model side-steps all state-mutation related problems like observer-set, if-then blocks, and friends because now, your entire app becomes readOnly.
    * (!slide with what redux gets you) furthermore, because state management with redux is centralized and side-effect-free, ember will be able to acquire such out-of-this world dev tools such as time-travel across states, distributed ember state syncing via crdt, and other redux middlewares.
    *  (!slide with facebook) besides, what's the worst thing that can happen when you trust your internal information to this corporation? All your react developer friends are doing it? C'mon, don't be such a square and take a hit of redux.
  - Delegate v. dumb components
    * (!slide with code) So let's say we install ember-redux and start writing redux-flavored ember code. We'll skip the 'Hello World' example, and instead go into something more interesting. Let's say we're building an internet streaming service that provides specialty movies and videos.
    * (!slide with gnatflix router.js) Our router.js file will have a `movies` index route where the user can browse the catalog of gnat movies our services offers, a `movies/:movie_id` route where the user can view in more detail things such as a rough summary of the movie and perhaps its rating and screenshots, and a `admin/movies/:movie_id/edit` route where an employee can edit the status of movie and possibly remove it from the catalog in the event we suddenly lose the license to it. Very standard ember stuff, with ember-data we would just do `this.store.findAll('movie')` in the movies index route and `this.store.findRecord('movie', id)` in the movie show and admin edit route and be done with that... but how would be do it in vanilla ember-redux
    * (!slide with movies-index-container and friends code) ember-redux (and also actually ember-routable-components if it ever lands) recommends either using the route model or writing a sort of 'async-delegate-component' to handle the `$.ajax` call that will fetch from the back-end server our data, so that once the remote data resolves, it can be presented to the user via `dumb-presentational-components` 
    * (!slide with more code) notice that your route's resolved model isn't actually used in the template (not passed to the component), and instead, some 'delegate-container-component' pulls the state out of redux. In addition, we flat-out skip writing controllers.
    * (!slide with the admin edit route) and if our admins are going to be making stateful changes to the movies (such as removing them from the catalog), we'd write an action handler that dispatches to our redux reducers to handle mutating the object value since we won't be able to use ember's `mut` helpers in the templates anymore

- Highlight the problems of using ember-redux out of the box
  - preamble
    * (!slide with meme) sounds good? I wouldn't say so.
  - Boilerplate with components like ‘route-dog-edit-container’ and boilerplate actions because no mut helper
    * (!slide with boilerplate) The problem is that we've gotten rid of a lot of familiar, tried, and battle-tested ember utilities and conventions that actually made building ambitious apps in ember doable and enjoyable, and replaced it with a ton of error-prone boilerplate javascript code that has objectively made our app more brittle because it exposed more surface area for an unruly developer to come in and mess up. 
    * (!slide with loading and error hbs files) Furthermore, redux has no way to track the `error` and `loading` states that routes can get into, made the use of named outlets now incredibly counter-intuitive, and introduced a ton of our own 'container' route components that differ from each other only by (!slide with routeNames) their routeNames, (!slide with queryParams) can't access queryParams, must access currently private routing service variables to figure out its routing state, and can't control their own outlets beyond yield and yield to=inverse... 
  - Async acceptance test helpers like ‘andThen’ are broken
    * (!slide with tests) On top of that, all your acceptance tests that involve user-driven async actions are now broken because your async test helpers like `andThen` will now instantly resolve on POST and PUT requests since they no longer have a centralized ds.store where the test testHelpers can listen into for resolutions 
  - No isolated IO layer means $.ajax, window.fetch, and friends in your components
    * (!slide with $) and on top of that, we've peppered these infernal I/O dollar signs eveywhere and completely lost the ability to customzie our adapters, serializers, and transforms, coalesce find requests, configure api endpoints, and all that jazz with our data layer.
    * (!slide with data layer) actually, we've lost all our data layer, so if you had fancy ideas of perhaps retrying certain request across mulitiple endpoints or switching your backend from firebase.io to your own elixir-phoenix server as your small business scales or other members of your big business upgrades stuff, you can either kiss all that goodbye, or enjoy slogging through the most creative and clever complexed code your newly hired intern wrote up for you when it inevitably breaks.
  - Ember-routeable-components is up in the air, so writing code is always dangerous
    * (!slide with routable components, module unification) and if past lessons teach us anything, no code written is future proof, therefore the less code you've written for your app, the more easily you can future-proof yourself against the new ember features / rfcs like routable components, module unifcation, and whatnot.
    * (!slide with bloated project) but when these new changes start coming to pass in ember 2.9+ or ember 3.x or whenever, there is almost no way in hell you'd be able to ride onto the latest ember if your app is burdered down with 300+ files and folders of boilerplate your team has written.
  - post-amble
    * (!slide with baby being grounded up) sure we're "cleaner" and more "pure" now, but in the process, we've just throw the baby, the sink, and much of the kitchen out with the bathwater, and then made sure no new kitchen can be built in their place.
- Present the ember-with-redux solution
  - preamble
    * So what do we do? (!slide with having and eating cake) We want both the transparent and clean state management solution of redux at the same time we refuse to give up any of our cherished ember traditions. Can we have our cake and eat it too? Fortunately the answer is yes. If we keep ember-data at the I/O boundaries of our app, manage state with ember-redux, and slightly extend some of ember and ember-data's api, we can have the best of both worlds. (!slide with ember-with-redux repo) and that's exactly what the ember-with-redux addon strives to do for you.

  - Show some example code
    - model files
      * (!slide with model file) with this addon, we declare our DS.Model files exactly as we have been doing
    - findRecord route
      * (!slide with findRecord route) With this addon, ds store’s findRecord method works exactly as you’re used to it working in traditional ember-data apps, except it now properly registers its state success, failure, and attempted states with redux.
      * (!slide with template.hbs file) Next up is the route template files. In traditional ember-data apps, we access the route model attributes via the model reference. In ember-with-redux, in addition to the resolved route model, we also introduce the `meta` and `data` references which contain POJOs pulled from redux.getState(). (!slide with meta and data type) Under the hood, meta and data are stored in an Immutable.Map object called the `routeModel` that is a computed property that getState() from redux based upon the current route. Meta is a POJO containing the { modelName, id } and other such meta data of your resolved routeModel while `data` is a flat POJO containing the values exactly as you declared in your model file. 
    - editRecord route
      * (!slide with Flanders) Next up are routes like 'new', and 'edit' that expose write-to-server operations. Now, because redux pushes for a side-effect free style of state management, we necessarily must introduce some new ideas to handle this in ember. Hold onto your butts, gang. (!slide with edit route) this addon introduces 2 additional methods to the DS.Store called `checkoutChangeset` and `persistChangeset` which, if you're familiar with DockYard's ember-changeset addons, present a way to both modify existing and create new DS.Models atomically and without side-effect (i.e. we now no longer have to hook into a route's deactivate method to check if the controller model is dirty to decide if we want to clean it up or not).
      * (!slide with edit template file) the checkoutChangeset creates a changeset which we can access via the `changeset` and `changes` key in the template file. This addon also introduces 2 new helpers `ds-mut-action` and `ds-persist-action` which work with changesets in much the same way `mut` does with regular ember objects.
      * notice that persist action returns a function (in this particular case in redux, it's called a thunk) which we dispatch over to the redux reducers for handling. (!slide with transition after persist) If we wished to do other stuff like effect transitions after the persist has completed, we'd have to pipe this function into our persisting one. One of the greatest benefits of this setup is that now, it's possible to keep async inside the model hook in the route (as opposed to in various component actions), though where the developer decides to place their async after persists is up to the developer.
    - queryRecord route
      * (!slide with index route) next, in index findAll or query routes, this addon extends the query function to now take one additional argument after the server-side search params that is the local map/filter/reduce/sort function which redux will use to locally determine membership to the final returned list
      * similarly, we access the list of returned data via the `list` reference in the template files
      * (!slide with free stuff) bear in the mind the query params is sent up to some remote upstream for data-querying that is entirely out of our hands, while the function (called a transducer by rich hickley) we pass in processes it afterwards. This way, any additional models pushed into our app state by either remote server push notifications, sockets, or what have you, automatically updates the index list, and thereby giving us live-updating to queried lists for free (which, incidentally, is currently not possible with vanilla ember-data)
    - route model and params
      * (!slide with util functions) finally, it's directly possible to access the route model and route params in the template as well as from redux state with these util functions; I won't go into them now, but they pretty much all do what their names suggest they do
  - Hand wave the store, route, and controller extensions
    * so how is all this done?
    * (!slide with reducer) well, this addon ships with a big reducer that tracks down and names most of the notable state changes in ember and ember-data
    * (!slide with the extensions) and we then extend the DS.Store, Ember.Route, and Ember.Controller files to properly register their states with redux as well as pull their computed properties from redux.getState()
    * (!slide with route and controller) A point of contention is why we extend route and controller instead of figure out some way to have ember automatically scaffold some container component. And it's because ember's route+controller combo serves *exactly* as the top-level container component; and if it walks like a duck and talks like a duck, we'll call it a duck. It so happens route+controller walks and talks exactly like "top-level container" component here in ember (except you can only have one Route of them per routeName).
  - Recap
    * (!slide with recap) So to recap:
    * use ember-redux and ember-data
    * keep all your state transition code in reducer functions
    * keep the rest of your app (e.g. components, routes, controllers, etc.) dumb as rocks
    * keep all your async I/O code in your adapter files

